# セルフレビュー

レビュー依頼前にPRの品質を上げる。良いPRは意図が明確で、ノイズが少なく、レビューしやすい。

網羅的なコードレビューではない。「出す前に自分で気づける明らかな問題」に絞る。

## Phase 1: 分析（変更なし）

全ステップで指摘事項を収集のみ行う。修正・コメント投稿は一切しない。

### 1. CIステータス確認

```bash
gh pr checks <URL>
```

失敗・エラーあり → 該当ジョブのログを確認し、原因を特定する。

**IMPORTANT: CI失敗時はPhase 1の残りのステップ（2〜7）をスキップし、即座にCI修正に着手する。** CIが通らない状態でdiffレビューやdescription確認を行っても、CI修正による変更で無効になる。CI修正を完了しpushした後、改めてセルフレビューを最初から実行する。

### 2. diffのノイズ検出

```bash
gh pr diff <URL>
```

検出対象:
- デバッグ用コード（console.log、print、コメントアウト）
- 無関係な変更（フォーマッタの自動修正、lock fileの差分）
- TODO/FIXMEの放置

diffが大きい場合（目安: 400行超） → 分割候補として記録。

### 3. PR descriptionと実装の整合性

```bash
gh pr view <URL> --json body,title
```

確認ポイント:
- タイトルが変更内容を正確に表しているか
- 動機（WHY）が明確か
- descriptionが実装内容と矛盾していないか
- 不要になった記述が残っていないか

### 4. コミット粒度

```bash
gh pr view <URL> --json commits
```

- 1コミットに複数の関心事が混ざっていないか
- コミットメッセージが変更内容を説明しているか

### 5. レビュアビリティ

レビュワーの視点でdiffを読み、以下を評価:
- 変更の意図が追いやすいか
- テストが変更に対応しているか
- エラーハンドリングに明らかな欠落がないか
- 破壊的変更（API変更、DB migration、環境変数追加）が明示されているか

### 6. レビュワー疑問の先回り

レビュワーが「なぜ？」と聞きたくなる箇所を洗い出す。指摘ゼロのApproveが理想。

検出対象:
- 理由が自明でない設計判断（アプローチの選択理由、却下した代替案）
- 意図が伝わりにくい命名（変数名・関数名・型名）
- 暗黙の副作用（状態変更、外部呼び出し、パフォーマンス影響）
- 既存パターンからの逸脱

各箇所の解消手段を記録:
- **コード修正**（優先）: リネーム・リファクタリング・コメント追加で疑問自体を消す
- **PRコメント**: コードで表現しきれない背景・トレードオフをdiffインラインコメントで補足

### 7. 未解決コメントの対応状況

```bash
~/.claude/skills/github-pr/gh-unresolved-threads <URL>
```

未解決コメントがある場合、各コメントを分類:

**対応不要（そのままでOK）:**
- コード説明のコメント、FYI的な情報共有、確認済みの指摘

**対応が必要:**
- 議論が残っている・回答待ちのスレッド

## Phase 2: 報告・議論

MUST: Phase 1の結果を一覧にしてユーザーに提示し、各指摘の対応方針を議論する。合意なく修正に着手しない。

指摘一覧を以下の形式で報告:

| # | 分類 | 内容 | 対応案 |
|---|------|------|--------|
| 1 | CI失敗 | ログの要約 | 修正方針 |
| 2 | ノイズ | 該当箇所 | 削除 or 残す理由 |
| ... | ... | ... | ... |

判断が必要な項目（値の選定、命名、設計判断など）は、前例調査や根拠を添える。

<example>
tracesSampleRateの値 → 同プロジェクトのconsole設定を確認し前例を提示 → 議論の上0.1に決定
関数リネーム → 既存の命名規則との整合性を提示 → 合意を得てから実施
</example>

指摘が0件の場合 → その旨を報告して完了。

## Phase 3: 実行

合意した方針に従い修正を実施。

### 未解決コメントへの対応

フェーズごとにまとめて進める（1件ずつ直列で完了させない）:

1. **対応宣言**: 全件に「対応します」とコメント（作業前に対応意思を先んじて伝える）
2. **実装**: 全件の修正をまとめて実施・コミット
3. **完了報告**: 全件に完了コメント+resolveをまとめて実行

完了コメントには対応理由を添える。自明な場合は簡潔でよい。

<example>
# Good: 理由あり
対応しました。nilチェックが漏れておりpanicの可能性がありました。

# Good: 自明な場合
対応しました。typo修正です。

# Bad: 理由なし
対応しました。
</example>

### スレッドへの返信

`gh-unresolved-threads`の出力に含まれる`id`（THREAD_ID）を使って返信する:

```bash
gh api graphql -f query='
  mutation {
    addPullRequestReviewThreadReply(input: {
      pullRequestReviewThreadId: "<THREAD_ID>"
      body: "返信内容"
    }) { comment { id } }
  }'
```

### スレッドのresolve

```bash
gh api graphql -f query='
  mutation {
    resolveReviewThread(input: {threadId: "<THREAD_ID>"}) {
      thread { isResolved }
    }
  }'
```

返信とresolveを両方行う場合は、返信→resolveの順で実行する。
